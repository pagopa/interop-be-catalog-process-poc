/* eslint-disable */
// @generated by protobuf-ts 2.9.1 with parameter eslint_disable
// @generated from protobuf file "v1/events.proto" (package "catalog", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message catalog.CatalogItemV1
 */
export interface CatalogItemV1 {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string producerId = 2;
   */
  producerId: string;
  /**
   * @generated from protobuf field: string name = 3;
   */
  name: string;
  /**
   * @generated from protobuf field: string description = 4;
   */
  description: string;
  /**
   * @generated from protobuf field: catalog.CatalogItemTechnologyV1 technology = 5;
   */
  technology: CatalogItemTechnologyV1;
  /**
   * @generated from protobuf field: optional catalog.CatalogAttributesV1 attributes = 6;
   */
  attributes?: CatalogAttributesV1;
  /**
   * @generated from protobuf field: repeated catalog.CatalogDescriptorV1 descriptors = 7;
   */
  descriptors: CatalogDescriptorV1[];
  /**
   * @generated from protobuf field: optional int64 createdAt = 8;
   */
  createdAt?: bigint;
  /**
   * @generated from protobuf field: repeated catalog.CatalogItemRiskAnalysisV1 riskAnalysis = 9;
   */
  riskAnalysis: CatalogItemRiskAnalysisV1[];
  /**
   * @generated from protobuf field: optional catalog.CatalogItemModeV1 mode = 10;
   */
  mode?: CatalogItemModeV1;
}
/**
 * @generated from protobuf message catalog.CatalogItemRiskAnalysisV1
 */
export interface CatalogItemRiskAnalysisV1 {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string name = 2;
   */
  name: string;
  /**
   * @generated from protobuf field: catalog.CatalogRiskAnalysisFormV1 riskAnalysisForm = 3;
   */
  riskAnalysisForm?: CatalogRiskAnalysisFormV1;
  /**
   * @generated from protobuf field: int64 createdAt = 4;
   */
  createdAt: bigint;
}
/**
 * @generated from protobuf message catalog.CatalogRiskAnalysisFormV1
 */
export interface CatalogRiskAnalysisFormV1 {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string version = 2;
   */
  version: string;
  /**
   * @generated from protobuf field: repeated catalog.CatalogRiskAnalysisSingleAnswerV1 singleAnswers = 3;
   */
  singleAnswers: CatalogRiskAnalysisSingleAnswerV1[];
  /**
   * @generated from protobuf field: repeated catalog.CatalogRiskAnalysisMultiAnswerV1 multiAnswers = 4;
   */
  multiAnswers: CatalogRiskAnalysisMultiAnswerV1[];
}
/**
 * @generated from protobuf message catalog.CatalogRiskAnalysisSingleAnswerV1
 */
export interface CatalogRiskAnalysisSingleAnswerV1 {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string key = 2;
   */
  key: string;
  /**
   * @generated from protobuf field: optional string value = 3;
   */
  value?: string;
}
/**
 * @generated from protobuf message catalog.CatalogRiskAnalysisMultiAnswerV1
 */
export interface CatalogRiskAnalysisMultiAnswerV1 {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string key = 2;
   */
  key: string;
  /**
   * @generated from protobuf field: repeated string values = 3;
   */
  values: string[];
}
/**
 * @generated from protobuf message catalog.CatalogAttributeValueV1
 */
export interface CatalogAttributeValueV1 {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: bool explicitAttributeVerification = 2;
   */
  explicitAttributeVerification: boolean;
}
/**
 * @generated from protobuf message catalog.CatalogAttributeV1
 */
export interface CatalogAttributeV1 {
  /**
   * @generated from protobuf field: optional catalog.CatalogAttributeValueV1 single = 1;
   */
  single?: CatalogAttributeValueV1;
  /**
   * @generated from protobuf field: repeated catalog.CatalogAttributeValueV1 group = 2;
   */
  group: CatalogAttributeValueV1[];
}
/**
 * @generated from protobuf message catalog.CatalogAttributesV1
 */
export interface CatalogAttributesV1 {
  /**
   * @generated from protobuf field: repeated catalog.CatalogAttributeV1 certified = 1;
   */
  certified: CatalogAttributeV1[];
  /**
   * @generated from protobuf field: repeated catalog.CatalogAttributeV1 declared = 2;
   */
  declared: CatalogAttributeV1[];
  /**
   * @generated from protobuf field: repeated catalog.CatalogAttributeV1 verified = 3;
   */
  verified: CatalogAttributeV1[];
}
/**
 * @generated from protobuf message catalog.CatalogDescriptorV1
 */
export interface CatalogDescriptorV1 {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string version = 2;
   */
  version: string;
  /**
   * @generated from protobuf field: optional string description = 3;
   */
  description?: string;
  /**
   * @generated from protobuf field: repeated catalog.CatalogDocumentV1 docs = 4;
   */
  docs: CatalogDocumentV1[];
  /**
   * @generated from protobuf field: catalog.CatalogDescriptorStateV1 state = 5;
   */
  state: CatalogDescriptorStateV1;
  /**
   * @generated from protobuf field: optional catalog.CatalogDocumentV1 interface = 6;
   */
  interface?: CatalogDocumentV1;
  /**
   * @generated from protobuf field: repeated string audience = 7;
   */
  audience: string[];
  /**
   * @generated from protobuf field: int32 voucherLifespan = 8;
   */
  voucherLifespan: number;
  /**
   * @generated from protobuf field: int32 dailyCallsPerConsumer = 9;
   */
  dailyCallsPerConsumer: number;
  /**
   * @generated from protobuf field: int32 dailyCallsTotal = 10;
   */
  dailyCallsTotal: number;
  /**
   * @generated from protobuf field: optional catalog.AgreementApprovalPolicyV1 agreementApprovalPolicy = 11;
   */
  agreementApprovalPolicy?: AgreementApprovalPolicyV1;
  /**
   * @generated from protobuf field: optional int64 createdAt = 12;
   */
  createdAt?: bigint;
  /**
   * @generated from protobuf field: optional int64 publishedAt = 13;
   */
  publishedAt?: bigint;
  /**
   * @generated from protobuf field: repeated string serverUrls = 14;
   */
  serverUrls: string[];
  /**
   * @generated from protobuf field: optional int64 suspendedAt = 15;
   */
  suspendedAt?: bigint;
  /**
   * @generated from protobuf field: optional int64 deprecatedAt = 16;
   */
  deprecatedAt?: bigint;
  /**
   * @generated from protobuf field: optional int64 archivedAt = 17;
   */
  archivedAt?: bigint;
  /**
   * @generated from protobuf field: optional catalog.CatalogAttributesV1 attributes = 18;
   */
  attributes?: CatalogAttributesV1;
}
/**
 * @generated from protobuf message catalog.CatalogDocumentV1
 */
export interface CatalogDocumentV1 {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string name = 2;
   */
  name: string;
  /**
   * @generated from protobuf field: string contentType = 3;
   */
  contentType: string;
  /**
   * @generated from protobuf field: string path = 4;
   */
  path: string;
  /**
   * @generated from protobuf field: string checksum = 5;
   */
  checksum: string;
  /**
   * @generated from protobuf field: string uploadDate = 6;
   */
  uploadDate: string;
  /**
   * @generated from protobuf field: string prettyName = 7;
   */
  prettyName: string;
}
/**
 * @generated from protobuf message catalog.CatalogItemV1AddedV1
 */
export interface CatalogItemV1AddedV1 {
  /**
   * @generated from protobuf field: catalog.CatalogItemV1 catalogItem = 1;
   */
  catalogItem?: CatalogItemV1;
}
/**
 * @generated from protobuf message catalog.ClonedCatalogItemV1AddedV1
 */
export interface ClonedCatalogItemV1AddedV1 {
  /**
   * @generated from protobuf field: catalog.CatalogItemV1 catalogItem = 1;
   */
  catalogItem?: CatalogItemV1;
}
/**
 * @generated from protobuf message catalog.CatalogItemV1UpdatedV1
 */
export interface CatalogItemV1UpdatedV1 {
  /**
   * @generated from protobuf field: catalog.CatalogItemV1 catalogItem = 1;
   */
  catalogItem?: CatalogItemV1;
}
/**
 * @generated from protobuf message catalog.CatalogItemWithDescriptorsDeletedV1
 */
export interface CatalogItemWithDescriptorsDeletedV1 {
  /**
   * @generated from protobuf field: catalog.CatalogItemV1 catalogItem = 1;
   */
  catalogItem?: CatalogItemV1;
  /**
   * @generated from protobuf field: string descriptorId = 2;
   */
  descriptorId: string;
}
/**
 * @generated from protobuf message catalog.CatalogItemDocumentUpdatedV1
 */
export interface CatalogItemDocumentUpdatedV1 {
  /**
   * @generated from protobuf field: string eServiceId = 1;
   */
  eServiceId: string;
  /**
   * @generated from protobuf field: string descriptorId = 2;
   */
  descriptorId: string;
  /**
   * @generated from protobuf field: string documentId = 3;
   */
  documentId: string;
  /**
   * @generated from protobuf field: catalog.CatalogDocumentV1 updatedDocument = 4;
   */
  updatedDocument?: CatalogDocumentV1;
  /**
   * @generated from protobuf field: repeated string serverUrls = 5;
   */
  serverUrls: string[];
}
/**
 * @generated from protobuf message catalog.CatalogItemDeletedV1
 */
export interface CatalogItemDeletedV1 {
  /**
   * @generated from protobuf field: string catalogItemId = 1;
   */
  catalogItemId: string;
}
/**
 * @generated from protobuf message catalog.CatalogItemDocumentAddedV1
 */
export interface CatalogItemDocumentAddedV1 {
  /**
   * @generated from protobuf field: string eServiceId = 1;
   */
  eServiceId: string;
  /**
   * @generated from protobuf field: string descriptorId = 2;
   */
  descriptorId: string;
  /**
   * @generated from protobuf field: catalog.CatalogDocumentV1 document = 3;
   */
  document?: CatalogDocumentV1;
  /**
   * @generated from protobuf field: bool isInterface = 4;
   */
  isInterface: boolean;
  /**
   * @generated from protobuf field: repeated string serverUrls = 5;
   */
  serverUrls: string[];
}
/**
 * @generated from protobuf message catalog.CatalogItemDocumentDeletedV1
 */
export interface CatalogItemDocumentDeletedV1 {
  /**
   * @generated from protobuf field: string eServiceId = 1;
   */
  eServiceId: string;
  /**
   * @generated from protobuf field: string descriptorId = 2;
   */
  descriptorId: string;
  /**
   * @generated from protobuf field: string documentId = 3;
   */
  documentId: string;
}
/**
 * @generated from protobuf message catalog.CatalogItemDescriptorAddedV1
 */
export interface CatalogItemDescriptorAddedV1 {
  /**
   * @generated from protobuf field: string eServiceId = 1;
   */
  eServiceId: string;
  /**
   * @generated from protobuf field: catalog.CatalogDescriptorV1 catalogDescriptor = 2;
   */
  catalogDescriptor?: CatalogDescriptorV1;
}
/**
 * @generated from protobuf message catalog.CatalogItemDescriptorUpdatedV1
 */
export interface CatalogItemDescriptorUpdatedV1 {
  /**
   * @generated from protobuf field: string eServiceId = 1;
   */
  eServiceId: string;
  /**
   * @generated from protobuf field: catalog.CatalogDescriptorV1 catalogDescriptor = 2;
   */
  catalogDescriptor?: CatalogDescriptorV1;
}
/**
 * @generated from protobuf message catalog.MovedAttributesFromEserviceToDescriptorsV1
 */
export interface MovedAttributesFromEserviceToDescriptorsV1 {
  /**
   * @generated from protobuf field: catalog.CatalogItemV1 catalogItem = 1;
   */
  catalogItem?: CatalogItemV1;
}
/**
 * @generated from protobuf message catalog.CatalogItemRiskAnalysisAddedV1
 */
export interface CatalogItemRiskAnalysisAddedV1 {
  /**
   * @generated from protobuf field: catalog.CatalogItemV1 catalogItem = 1;
   */
  catalogItem?: CatalogItemV1;
  /**
   * @generated from protobuf field: string catalogRiskAnalysisId = 2;
   */
  catalogRiskAnalysisId: string;
}
/**
 * @generated from protobuf message catalog.CatalogItemRiskAnalysisUpdatedV1
 */
export interface CatalogItemRiskAnalysisUpdatedV1 {
  /**
   * @generated from protobuf field: catalog.CatalogItemV1 catalogItem = 1;
   */
  catalogItem?: CatalogItemV1;
  /**
   * @generated from protobuf field: string catalogRiskAnalysisId = 2;
   */
  catalogRiskAnalysisId: string;
}
/**
 * @generated from protobuf message catalog.CatalogItemRiskAnalysisDeletedV1
 */
export interface CatalogItemRiskAnalysisDeletedV1 {
  /**
   * @generated from protobuf field: catalog.CatalogItemV1 catalogItem = 1;
   */
  catalogItem?: CatalogItemV1;
  /**
   * @generated from protobuf field: string catalogRiskAnalysisId = 2;
   */
  catalogRiskAnalysisId: string;
}
/**
 * @generated from protobuf enum catalog.CatalogDescriptorStateV1
 */
export enum CatalogDescriptorStateV1 {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: DRAFT = 1;
   */
  DRAFT = 1,
  /**
   * @generated from protobuf enum value: PUBLISHED = 2;
   */
  PUBLISHED = 2,
  /**
   * @generated from protobuf enum value: DEPRECATED = 3;
   */
  DEPRECATED = 3,
  /**
   * @generated from protobuf enum value: SUSPENDED = 4;
   */
  SUSPENDED = 4,
  /**
   * @generated from protobuf enum value: ARCHIVED = 5;
   */
  ARCHIVED = 5,
}
/**
 * @generated from protobuf enum catalog.CatalogItemTechnologyV1
 */
export enum CatalogItemTechnologyV1 {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: REST = 1;
   */
  REST = 1,
  /**
   * @generated from protobuf enum value: SOAP = 2;
   */
  SOAP = 2,
}
/**
 * @generated from protobuf enum catalog.AgreementApprovalPolicyV1
 */
export enum AgreementApprovalPolicyV1 {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: AUTOMATIC = 1;
   */
  AUTOMATIC = 1,
  /**
   * @generated from protobuf enum value: MANUAL = 2;
   */
  MANUAL = 2,
}
/**
 * @generated from protobuf enum catalog.CatalogItemModeV1
 */
export enum CatalogItemModeV1 {
  /**
   * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
   */
  UNSPECIFIED$ = 0,
  /**
   * @generated from protobuf enum value: RECEIVE = 1;
   */
  RECEIVE = 1,
  /**
   * @generated from protobuf enum value: DELIVER = 2;
   */
  DELIVER = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemV1$Type extends MessageType<CatalogItemV1> {
  constructor() {
    super("catalog.CatalogItemV1", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "producerId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "technology",
        kind: "enum",
        T: () => ["catalog.CatalogItemTechnologyV1", CatalogItemTechnologyV1],
      },
      {
        no: 6,
        name: "attributes",
        kind: "message",
        T: () => CatalogAttributesV1,
      },
      {
        no: 7,
        name: "descriptors",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogDescriptorV1,
      },
      {
        no: 8,
        name: "createdAt",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 9,
        name: "riskAnalysis",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogItemRiskAnalysisV1,
      },
      {
        no: 10,
        name: "mode",
        kind: "enum",
        opt: true,
        T: () => ["catalog.CatalogItemModeV1", CatalogItemModeV1],
      },
    ]);
  }
  create(value?: PartialMessage<CatalogItemV1>): CatalogItemV1 {
    const message = {
      id: "",
      producerId: "",
      name: "",
      description: "",
      technology: 0,
      descriptors: [],
      riskAnalysis: [],
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemV1
  ): CatalogItemV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string producerId */ 2:
          message.producerId = reader.string();
          break;
        case /* string name */ 3:
          message.name = reader.string();
          break;
        case /* string description */ 4:
          message.description = reader.string();
          break;
        case /* catalog.CatalogItemTechnologyV1 technology */ 5:
          message.technology = reader.int32();
          break;
        case /* optional catalog.CatalogAttributesV1 attributes */ 6:
          message.attributes = CatalogAttributesV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.attributes
          );
          break;
        case /* repeated catalog.CatalogDescriptorV1 descriptors */ 7:
          message.descriptors.push(
            CatalogDescriptorV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        case /* optional int64 createdAt */ 8:
          message.createdAt = reader.int64().toBigInt();
          break;
        case /* repeated catalog.CatalogItemRiskAnalysisV1 riskAnalysis */ 9:
          message.riskAnalysis.push(
            CatalogItemRiskAnalysisV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        case /* optional catalog.CatalogItemModeV1 mode */ 10:
          message.mode = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string producerId = 2; */
    if (message.producerId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.producerId);
    /* string name = 3; */
    if (message.name !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.name);
    /* string description = 4; */
    if (message.description !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.description);
    /* catalog.CatalogItemTechnologyV1 technology = 5; */
    if (message.technology !== 0)
      writer.tag(5, WireType.Varint).int32(message.technology);
    /* optional catalog.CatalogAttributesV1 attributes = 6; */
    if (message.attributes)
      CatalogAttributesV1.internalBinaryWrite(
        message.attributes,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* repeated catalog.CatalogDescriptorV1 descriptors = 7; */
    for (let i = 0; i < message.descriptors.length; i++)
      CatalogDescriptorV1.internalBinaryWrite(
        message.descriptors[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* optional int64 createdAt = 8; */
    if (message.createdAt !== undefined)
      writer.tag(8, WireType.Varint).int64(message.createdAt);
    /* repeated catalog.CatalogItemRiskAnalysisV1 riskAnalysis = 9; */
    for (let i = 0; i < message.riskAnalysis.length; i++)
      CatalogItemRiskAnalysisV1.internalBinaryWrite(
        message.riskAnalysis[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* optional catalog.CatalogItemModeV1 mode = 10; */
    if (message.mode !== undefined)
      writer.tag(10, WireType.Varint).int32(message.mode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemV1
 */
export const CatalogItemV1 = new CatalogItemV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemRiskAnalysisV1$Type extends MessageType<CatalogItemRiskAnalysisV1> {
  constructor() {
    super("catalog.CatalogItemRiskAnalysisV1", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "riskAnalysisForm",
        kind: "message",
        T: () => CatalogRiskAnalysisFormV1,
      },
      {
        no: 4,
        name: "createdAt",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemRiskAnalysisV1>
  ): CatalogItemRiskAnalysisV1 {
    const message = { id: "", name: "", createdAt: 0n };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemRiskAnalysisV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemRiskAnalysisV1
  ): CatalogItemRiskAnalysisV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* catalog.CatalogRiskAnalysisFormV1 riskAnalysisForm */ 3:
          message.riskAnalysisForm =
            CatalogRiskAnalysisFormV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.riskAnalysisForm
            );
          break;
        case /* int64 createdAt */ 4:
          message.createdAt = reader.int64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemRiskAnalysisV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string name = 2; */
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    /* catalog.CatalogRiskAnalysisFormV1 riskAnalysisForm = 3; */
    if (message.riskAnalysisForm)
      CatalogRiskAnalysisFormV1.internalBinaryWrite(
        message.riskAnalysisForm,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* int64 createdAt = 4; */
    if (message.createdAt !== 0n)
      writer.tag(4, WireType.Varint).int64(message.createdAt);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemRiskAnalysisV1
 */
export const CatalogItemRiskAnalysisV1 = new CatalogItemRiskAnalysisV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogRiskAnalysisFormV1$Type extends MessageType<CatalogRiskAnalysisFormV1> {
  constructor() {
    super("catalog.CatalogRiskAnalysisFormV1", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "singleAnswers",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogRiskAnalysisSingleAnswerV1,
      },
      {
        no: 4,
        name: "multiAnswers",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogRiskAnalysisMultiAnswerV1,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogRiskAnalysisFormV1>
  ): CatalogRiskAnalysisFormV1 {
    const message = {
      id: "",
      version: "",
      singleAnswers: [],
      multiAnswers: [],
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogRiskAnalysisFormV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogRiskAnalysisFormV1
  ): CatalogRiskAnalysisFormV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string version */ 2:
          message.version = reader.string();
          break;
        case /* repeated catalog.CatalogRiskAnalysisSingleAnswerV1 singleAnswers */ 3:
          message.singleAnswers.push(
            CatalogRiskAnalysisSingleAnswerV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        case /* repeated catalog.CatalogRiskAnalysisMultiAnswerV1 multiAnswers */ 4:
          message.multiAnswers.push(
            CatalogRiskAnalysisMultiAnswerV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogRiskAnalysisFormV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string version = 2; */
    if (message.version !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.version);
    /* repeated catalog.CatalogRiskAnalysisSingleAnswerV1 singleAnswers = 3; */
    for (let i = 0; i < message.singleAnswers.length; i++)
      CatalogRiskAnalysisSingleAnswerV1.internalBinaryWrite(
        message.singleAnswers[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* repeated catalog.CatalogRiskAnalysisMultiAnswerV1 multiAnswers = 4; */
    for (let i = 0; i < message.multiAnswers.length; i++)
      CatalogRiskAnalysisMultiAnswerV1.internalBinaryWrite(
        message.multiAnswers[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogRiskAnalysisFormV1
 */
export const CatalogRiskAnalysisFormV1 = new CatalogRiskAnalysisFormV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogRiskAnalysisSingleAnswerV1$Type extends MessageType<CatalogRiskAnalysisSingleAnswerV1> {
  constructor() {
    super("catalog.CatalogRiskAnalysisSingleAnswerV1", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "value",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogRiskAnalysisSingleAnswerV1>
  ): CatalogRiskAnalysisSingleAnswerV1 {
    const message = { id: "", key: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogRiskAnalysisSingleAnswerV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogRiskAnalysisSingleAnswerV1
  ): CatalogRiskAnalysisSingleAnswerV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string key */ 2:
          message.key = reader.string();
          break;
        case /* optional string value */ 3:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogRiskAnalysisSingleAnswerV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string key = 2; */
    if (message.key !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.key);
    /* optional string value = 3; */
    if (message.value !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogRiskAnalysisSingleAnswerV1
 */
export const CatalogRiskAnalysisSingleAnswerV1 =
  new CatalogRiskAnalysisSingleAnswerV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogRiskAnalysisMultiAnswerV1$Type extends MessageType<CatalogRiskAnalysisMultiAnswerV1> {
  constructor() {
    super("catalog.CatalogRiskAnalysisMultiAnswerV1", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "values",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogRiskAnalysisMultiAnswerV1>
  ): CatalogRiskAnalysisMultiAnswerV1 {
    const message = { id: "", key: "", values: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogRiskAnalysisMultiAnswerV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogRiskAnalysisMultiAnswerV1
  ): CatalogRiskAnalysisMultiAnswerV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string key */ 2:
          message.key = reader.string();
          break;
        case /* repeated string values */ 3:
          message.values.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogRiskAnalysisMultiAnswerV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string key = 2; */
    if (message.key !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.key);
    /* repeated string values = 3; */
    for (let i = 0; i < message.values.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.values[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogRiskAnalysisMultiAnswerV1
 */
export const CatalogRiskAnalysisMultiAnswerV1 =
  new CatalogRiskAnalysisMultiAnswerV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogAttributeValueV1$Type extends MessageType<CatalogAttributeValueV1> {
  constructor() {
    super("catalog.CatalogAttributeValueV1", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "explicitAttributeVerification",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogAttributeValueV1>
  ): CatalogAttributeValueV1 {
    const message = { id: "", explicitAttributeVerification: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogAttributeValueV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogAttributeValueV1
  ): CatalogAttributeValueV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* bool explicitAttributeVerification */ 2:
          message.explicitAttributeVerification = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogAttributeValueV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* bool explicitAttributeVerification = 2; */
    if (message.explicitAttributeVerification !== false)
      writer
        .tag(2, WireType.Varint)
        .bool(message.explicitAttributeVerification);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogAttributeValueV1
 */
export const CatalogAttributeValueV1 = new CatalogAttributeValueV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogAttributeV1$Type extends MessageType<CatalogAttributeV1> {
  constructor() {
    super("catalog.CatalogAttributeV1", [
      {
        no: 1,
        name: "single",
        kind: "message",
        T: () => CatalogAttributeValueV1,
      },
      {
        no: 2,
        name: "group",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogAttributeValueV1,
      },
    ]);
  }
  create(value?: PartialMessage<CatalogAttributeV1>): CatalogAttributeV1 {
    const message = { group: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogAttributeV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogAttributeV1
  ): CatalogAttributeV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional catalog.CatalogAttributeValueV1 single */ 1:
          message.single = CatalogAttributeValueV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.single
          );
          break;
        case /* repeated catalog.CatalogAttributeValueV1 group */ 2:
          message.group.push(
            CatalogAttributeValueV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogAttributeV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional catalog.CatalogAttributeValueV1 single = 1; */
    if (message.single)
      CatalogAttributeValueV1.internalBinaryWrite(
        message.single,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* repeated catalog.CatalogAttributeValueV1 group = 2; */
    for (let i = 0; i < message.group.length; i++)
      CatalogAttributeValueV1.internalBinaryWrite(
        message.group[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogAttributeV1
 */
export const CatalogAttributeV1 = new CatalogAttributeV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogAttributesV1$Type extends MessageType<CatalogAttributesV1> {
  constructor() {
    super("catalog.CatalogAttributesV1", [
      {
        no: 1,
        name: "certified",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogAttributeV1,
      },
      {
        no: 2,
        name: "declared",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogAttributeV1,
      },
      {
        no: 3,
        name: "verified",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogAttributeV1,
      },
    ]);
  }
  create(value?: PartialMessage<CatalogAttributesV1>): CatalogAttributesV1 {
    const message = { certified: [], declared: [], verified: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogAttributesV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogAttributesV1
  ): CatalogAttributesV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated catalog.CatalogAttributeV1 certified */ 1:
          message.certified.push(
            CatalogAttributeV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        case /* repeated catalog.CatalogAttributeV1 declared */ 2:
          message.declared.push(
            CatalogAttributeV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        case /* repeated catalog.CatalogAttributeV1 verified */ 3:
          message.verified.push(
            CatalogAttributeV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogAttributesV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated catalog.CatalogAttributeV1 certified = 1; */
    for (let i = 0; i < message.certified.length; i++)
      CatalogAttributeV1.internalBinaryWrite(
        message.certified[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* repeated catalog.CatalogAttributeV1 declared = 2; */
    for (let i = 0; i < message.declared.length; i++)
      CatalogAttributeV1.internalBinaryWrite(
        message.declared[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* repeated catalog.CatalogAttributeV1 verified = 3; */
    for (let i = 0; i < message.verified.length; i++)
      CatalogAttributeV1.internalBinaryWrite(
        message.verified[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogAttributesV1
 */
export const CatalogAttributesV1 = new CatalogAttributesV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogDescriptorV1$Type extends MessageType<CatalogDescriptorV1> {
  constructor() {
    super("catalog.CatalogDescriptorV1", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "description",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "docs",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CatalogDocumentV1,
      },
      {
        no: 5,
        name: "state",
        kind: "enum",
        T: () => ["catalog.CatalogDescriptorStateV1", CatalogDescriptorStateV1],
      },
      { no: 6, name: "interface", kind: "message", T: () => CatalogDocumentV1 },
      {
        no: 7,
        name: "audience",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 8,
        name: "voucherLifespan",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 9,
        name: "dailyCallsPerConsumer",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 10,
        name: "dailyCallsTotal",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 11,
        name: "agreementApprovalPolicy",
        kind: "enum",
        opt: true,
        T: () => [
          "catalog.AgreementApprovalPolicyV1",
          AgreementApprovalPolicyV1,
        ],
      },
      {
        no: 12,
        name: "createdAt",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 13,
        name: "publishedAt",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 14,
        name: "serverUrls",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 15,
        name: "suspendedAt",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 16,
        name: "deprecatedAt",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 17,
        name: "archivedAt",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 18,
        name: "attributes",
        kind: "message",
        T: () => CatalogAttributesV1,
      },
    ]);
  }
  create(value?: PartialMessage<CatalogDescriptorV1>): CatalogDescriptorV1 {
    const message = {
      id: "",
      version: "",
      docs: [],
      state: 0,
      audience: [],
      voucherLifespan: 0,
      dailyCallsPerConsumer: 0,
      dailyCallsTotal: 0,
      serverUrls: [],
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogDescriptorV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogDescriptorV1
  ): CatalogDescriptorV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string version */ 2:
          message.version = reader.string();
          break;
        case /* optional string description */ 3:
          message.description = reader.string();
          break;
        case /* repeated catalog.CatalogDocumentV1 docs */ 4:
          message.docs.push(
            CatalogDocumentV1.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          );
          break;
        case /* catalog.CatalogDescriptorStateV1 state */ 5:
          message.state = reader.int32();
          break;
        case /* optional catalog.CatalogDocumentV1 interface */ 6:
          message.interface = CatalogDocumentV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.interface
          );
          break;
        case /* repeated string audience */ 7:
          message.audience.push(reader.string());
          break;
        case /* int32 voucherLifespan */ 8:
          message.voucherLifespan = reader.int32();
          break;
        case /* int32 dailyCallsPerConsumer */ 9:
          message.dailyCallsPerConsumer = reader.int32();
          break;
        case /* int32 dailyCallsTotal */ 10:
          message.dailyCallsTotal = reader.int32();
          break;
        case /* optional catalog.AgreementApprovalPolicyV1 agreementApprovalPolicy */ 11:
          message.agreementApprovalPolicy = reader.int32();
          break;
        case /* optional int64 createdAt */ 12:
          message.createdAt = reader.int64().toBigInt();
          break;
        case /* optional int64 publishedAt */ 13:
          message.publishedAt = reader.int64().toBigInt();
          break;
        case /* repeated string serverUrls */ 14:
          message.serverUrls.push(reader.string());
          break;
        case /* optional int64 suspendedAt */ 15:
          message.suspendedAt = reader.int64().toBigInt();
          break;
        case /* optional int64 deprecatedAt */ 16:
          message.deprecatedAt = reader.int64().toBigInt();
          break;
        case /* optional int64 archivedAt */ 17:
          message.archivedAt = reader.int64().toBigInt();
          break;
        case /* optional catalog.CatalogAttributesV1 attributes */ 18:
          message.attributes = CatalogAttributesV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.attributes
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogDescriptorV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string version = 2; */
    if (message.version !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.version);
    /* optional string description = 3; */
    if (message.description !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.description);
    /* repeated catalog.CatalogDocumentV1 docs = 4; */
    for (let i = 0; i < message.docs.length; i++)
      CatalogDocumentV1.internalBinaryWrite(
        message.docs[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* catalog.CatalogDescriptorStateV1 state = 5; */
    if (message.state !== 0)
      writer.tag(5, WireType.Varint).int32(message.state);
    /* optional catalog.CatalogDocumentV1 interface = 6; */
    if (message.interface)
      CatalogDocumentV1.internalBinaryWrite(
        message.interface,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* repeated string audience = 7; */
    for (let i = 0; i < message.audience.length; i++)
      writer.tag(7, WireType.LengthDelimited).string(message.audience[i]);
    /* int32 voucherLifespan = 8; */
    if (message.voucherLifespan !== 0)
      writer.tag(8, WireType.Varint).int32(message.voucherLifespan);
    /* int32 dailyCallsPerConsumer = 9; */
    if (message.dailyCallsPerConsumer !== 0)
      writer.tag(9, WireType.Varint).int32(message.dailyCallsPerConsumer);
    /* int32 dailyCallsTotal = 10; */
    if (message.dailyCallsTotal !== 0)
      writer.tag(10, WireType.Varint).int32(message.dailyCallsTotal);
    /* optional catalog.AgreementApprovalPolicyV1 agreementApprovalPolicy = 11; */
    if (message.agreementApprovalPolicy !== undefined)
      writer.tag(11, WireType.Varint).int32(message.agreementApprovalPolicy);
    /* optional int64 createdAt = 12; */
    if (message.createdAt !== undefined)
      writer.tag(12, WireType.Varint).int64(message.createdAt);
    /* optional int64 publishedAt = 13; */
    if (message.publishedAt !== undefined)
      writer.tag(13, WireType.Varint).int64(message.publishedAt);
    /* repeated string serverUrls = 14; */
    for (let i = 0; i < message.serverUrls.length; i++)
      writer.tag(14, WireType.LengthDelimited).string(message.serverUrls[i]);
    /* optional int64 suspendedAt = 15; */
    if (message.suspendedAt !== undefined)
      writer.tag(15, WireType.Varint).int64(message.suspendedAt);
    /* optional int64 deprecatedAt = 16; */
    if (message.deprecatedAt !== undefined)
      writer.tag(16, WireType.Varint).int64(message.deprecatedAt);
    /* optional int64 archivedAt = 17; */
    if (message.archivedAt !== undefined)
      writer.tag(17, WireType.Varint).int64(message.archivedAt);
    /* optional catalog.CatalogAttributesV1 attributes = 18; */
    if (message.attributes)
      CatalogAttributesV1.internalBinaryWrite(
        message.attributes,
        writer.tag(18, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogDescriptorV1
 */
export const CatalogDescriptorV1 = new CatalogDescriptorV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogDocumentV1$Type extends MessageType<CatalogDocumentV1> {
  constructor() {
    super("catalog.CatalogDocumentV1", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "contentType",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 4, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "checksum", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: "uploadDate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: "prettyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<CatalogDocumentV1>): CatalogDocumentV1 {
    const message = {
      id: "",
      name: "",
      contentType: "",
      path: "",
      checksum: "",
      uploadDate: "",
      prettyName: "",
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogDocumentV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogDocumentV1
  ): CatalogDocumentV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* string contentType */ 3:
          message.contentType = reader.string();
          break;
        case /* string path */ 4:
          message.path = reader.string();
          break;
        case /* string checksum */ 5:
          message.checksum = reader.string();
          break;
        case /* string uploadDate */ 6:
          message.uploadDate = reader.string();
          break;
        case /* string prettyName */ 7:
          message.prettyName = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogDocumentV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string name = 2; */
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    /* string contentType = 3; */
    if (message.contentType !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.contentType);
    /* string path = 4; */
    if (message.path !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.path);
    /* string checksum = 5; */
    if (message.checksum !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.checksum);
    /* string uploadDate = 6; */
    if (message.uploadDate !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.uploadDate);
    /* string prettyName = 7; */
    if (message.prettyName !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.prettyName);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogDocumentV1
 */
export const CatalogDocumentV1 = new CatalogDocumentV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemV1AddedV1$Type extends MessageType<CatalogItemV1AddedV1> {
  constructor() {
    super("catalog.CatalogItemV1AddedV1", [
      { no: 1, name: "catalogItem", kind: "message", T: () => CatalogItemV1 },
    ]);
  }
  create(value?: PartialMessage<CatalogItemV1AddedV1>): CatalogItemV1AddedV1 {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemV1AddedV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemV1AddedV1
  ): CatalogItemV1AddedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* catalog.CatalogItemV1 catalogItem */ 1:
          message.catalogItem = CatalogItemV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogItem
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemV1AddedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* catalog.CatalogItemV1 catalogItem = 1; */
    if (message.catalogItem)
      CatalogItemV1.internalBinaryWrite(
        message.catalogItem,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemV1AddedV1
 */
export const CatalogItemV1AddedV1 = new CatalogItemV1AddedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClonedCatalogItemV1AddedV1$Type extends MessageType<ClonedCatalogItemV1AddedV1> {
  constructor() {
    super("catalog.ClonedCatalogItemV1AddedV1", [
      { no: 1, name: "catalogItem", kind: "message", T: () => CatalogItemV1 },
    ]);
  }
  create(
    value?: PartialMessage<ClonedCatalogItemV1AddedV1>
  ): ClonedCatalogItemV1AddedV1 {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ClonedCatalogItemV1AddedV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClonedCatalogItemV1AddedV1
  ): ClonedCatalogItemV1AddedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* catalog.CatalogItemV1 catalogItem */ 1:
          message.catalogItem = CatalogItemV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogItem
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ClonedCatalogItemV1AddedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* catalog.CatalogItemV1 catalogItem = 1; */
    if (message.catalogItem)
      CatalogItemV1.internalBinaryWrite(
        message.catalogItem,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.ClonedCatalogItemV1AddedV1
 */
export const ClonedCatalogItemV1AddedV1 = new ClonedCatalogItemV1AddedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemV1UpdatedV1$Type extends MessageType<CatalogItemV1UpdatedV1> {
  constructor() {
    super("catalog.CatalogItemV1UpdatedV1", [
      { no: 1, name: "catalogItem", kind: "message", T: () => CatalogItemV1 },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemV1UpdatedV1>
  ): CatalogItemV1UpdatedV1 {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemV1UpdatedV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemV1UpdatedV1
  ): CatalogItemV1UpdatedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* catalog.CatalogItemV1 catalogItem */ 1:
          message.catalogItem = CatalogItemV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogItem
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemV1UpdatedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* catalog.CatalogItemV1 catalogItem = 1; */
    if (message.catalogItem)
      CatalogItemV1.internalBinaryWrite(
        message.catalogItem,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemV1UpdatedV1
 */
export const CatalogItemV1UpdatedV1 = new CatalogItemV1UpdatedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemWithDescriptorsDeletedV1$Type extends MessageType<CatalogItemWithDescriptorsDeletedV1> {
  constructor() {
    super("catalog.CatalogItemWithDescriptorsDeletedV1", [
      { no: 1, name: "catalogItem", kind: "message", T: () => CatalogItemV1 },
      {
        no: 2,
        name: "descriptorId",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemWithDescriptorsDeletedV1>
  ): CatalogItemWithDescriptorsDeletedV1 {
    const message = { descriptorId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemWithDescriptorsDeletedV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemWithDescriptorsDeletedV1
  ): CatalogItemWithDescriptorsDeletedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* catalog.CatalogItemV1 catalogItem */ 1:
          message.catalogItem = CatalogItemV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogItem
          );
          break;
        case /* string descriptorId */ 2:
          message.descriptorId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemWithDescriptorsDeletedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* catalog.CatalogItemV1 catalogItem = 1; */
    if (message.catalogItem)
      CatalogItemV1.internalBinaryWrite(
        message.catalogItem,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* string descriptorId = 2; */
    if (message.descriptorId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.descriptorId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemWithDescriptorsDeletedV1
 */
export const CatalogItemWithDescriptorsDeletedV1 =
  new CatalogItemWithDescriptorsDeletedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemDocumentUpdatedV1$Type extends MessageType<CatalogItemDocumentUpdatedV1> {
  constructor() {
    super("catalog.CatalogItemDocumentUpdatedV1", [
      { no: 1, name: "eServiceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "descriptorId",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "documentId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: "updatedDocument",
        kind: "message",
        T: () => CatalogDocumentV1,
      },
      {
        no: 5,
        name: "serverUrls",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemDocumentUpdatedV1>
  ): CatalogItemDocumentUpdatedV1 {
    const message = {
      eServiceId: "",
      descriptorId: "",
      documentId: "",
      serverUrls: [],
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemDocumentUpdatedV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemDocumentUpdatedV1
  ): CatalogItemDocumentUpdatedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string eServiceId */ 1:
          message.eServiceId = reader.string();
          break;
        case /* string descriptorId */ 2:
          message.descriptorId = reader.string();
          break;
        case /* string documentId */ 3:
          message.documentId = reader.string();
          break;
        case /* catalog.CatalogDocumentV1 updatedDocument */ 4:
          message.updatedDocument = CatalogDocumentV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.updatedDocument
          );
          break;
        case /* repeated string serverUrls */ 5:
          message.serverUrls.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemDocumentUpdatedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string eServiceId = 1; */
    if (message.eServiceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.eServiceId);
    /* string descriptorId = 2; */
    if (message.descriptorId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.descriptorId);
    /* string documentId = 3; */
    if (message.documentId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.documentId);
    /* catalog.CatalogDocumentV1 updatedDocument = 4; */
    if (message.updatedDocument)
      CatalogDocumentV1.internalBinaryWrite(
        message.updatedDocument,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* repeated string serverUrls = 5; */
    for (let i = 0; i < message.serverUrls.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.serverUrls[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemDocumentUpdatedV1
 */
export const CatalogItemDocumentUpdatedV1 =
  new CatalogItemDocumentUpdatedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemDeletedV1$Type extends MessageType<CatalogItemDeletedV1> {
  constructor() {
    super("catalog.CatalogItemDeletedV1", [
      {
        no: 1,
        name: "catalogItemId",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CatalogItemDeletedV1>): CatalogItemDeletedV1 {
    const message = { catalogItemId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemDeletedV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemDeletedV1
  ): CatalogItemDeletedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string catalogItemId */ 1:
          message.catalogItemId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemDeletedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string catalogItemId = 1; */
    if (message.catalogItemId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.catalogItemId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemDeletedV1
 */
export const CatalogItemDeletedV1 = new CatalogItemDeletedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemDocumentAddedV1$Type extends MessageType<CatalogItemDocumentAddedV1> {
  constructor() {
    super("catalog.CatalogItemDocumentAddedV1", [
      { no: 1, name: "eServiceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "descriptorId",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "document", kind: "message", T: () => CatalogDocumentV1 },
      { no: 4, name: "isInterface", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 5,
        name: "serverUrls",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemDocumentAddedV1>
  ): CatalogItemDocumentAddedV1 {
    const message = {
      eServiceId: "",
      descriptorId: "",
      isInterface: false,
      serverUrls: [],
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemDocumentAddedV1>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemDocumentAddedV1
  ): CatalogItemDocumentAddedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string eServiceId */ 1:
          message.eServiceId = reader.string();
          break;
        case /* string descriptorId */ 2:
          message.descriptorId = reader.string();
          break;
        case /* catalog.CatalogDocumentV1 document */ 3:
          message.document = CatalogDocumentV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.document
          );
          break;
        case /* bool isInterface */ 4:
          message.isInterface = reader.bool();
          break;
        case /* repeated string serverUrls */ 5:
          message.serverUrls.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemDocumentAddedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string eServiceId = 1; */
    if (message.eServiceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.eServiceId);
    /* string descriptorId = 2; */
    if (message.descriptorId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.descriptorId);
    /* catalog.CatalogDocumentV1 document = 3; */
    if (message.document)
      CatalogDocumentV1.internalBinaryWrite(
        message.document,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* bool isInterface = 4; */
    if (message.isInterface !== false)
      writer.tag(4, WireType.Varint).bool(message.isInterface);
    /* repeated string serverUrls = 5; */
    for (let i = 0; i < message.serverUrls.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.serverUrls[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemDocumentAddedV1
 */
export const CatalogItemDocumentAddedV1 = new CatalogItemDocumentAddedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemDocumentDeletedV1$Type extends MessageType<CatalogItemDocumentDeletedV1> {
  constructor() {
    super("catalog.CatalogItemDocumentDeletedV1", [
      { no: 1, name: "eServiceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "descriptorId",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "documentId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemDocumentDeletedV1>
  ): CatalogItemDocumentDeletedV1 {
    const message = { eServiceId: "", descriptorId: "", documentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemDocumentDeletedV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemDocumentDeletedV1
  ): CatalogItemDocumentDeletedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string eServiceId */ 1:
          message.eServiceId = reader.string();
          break;
        case /* string descriptorId */ 2:
          message.descriptorId = reader.string();
          break;
        case /* string documentId */ 3:
          message.documentId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemDocumentDeletedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string eServiceId = 1; */
    if (message.eServiceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.eServiceId);
    /* string descriptorId = 2; */
    if (message.descriptorId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.descriptorId);
    /* string documentId = 3; */
    if (message.documentId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.documentId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemDocumentDeletedV1
 */
export const CatalogItemDocumentDeletedV1 =
  new CatalogItemDocumentDeletedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemDescriptorAddedV1$Type extends MessageType<CatalogItemDescriptorAddedV1> {
  constructor() {
    super("catalog.CatalogItemDescriptorAddedV1", [
      { no: 1, name: "eServiceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "catalogDescriptor",
        kind: "message",
        T: () => CatalogDescriptorV1,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemDescriptorAddedV1>
  ): CatalogItemDescriptorAddedV1 {
    const message = { eServiceId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemDescriptorAddedV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemDescriptorAddedV1
  ): CatalogItemDescriptorAddedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string eServiceId */ 1:
          message.eServiceId = reader.string();
          break;
        case /* catalog.CatalogDescriptorV1 catalogDescriptor */ 2:
          message.catalogDescriptor = CatalogDescriptorV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogDescriptor
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemDescriptorAddedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string eServiceId = 1; */
    if (message.eServiceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.eServiceId);
    /* catalog.CatalogDescriptorV1 catalogDescriptor = 2; */
    if (message.catalogDescriptor)
      CatalogDescriptorV1.internalBinaryWrite(
        message.catalogDescriptor,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemDescriptorAddedV1
 */
export const CatalogItemDescriptorAddedV1 =
  new CatalogItemDescriptorAddedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemDescriptorUpdatedV1$Type extends MessageType<CatalogItemDescriptorUpdatedV1> {
  constructor() {
    super("catalog.CatalogItemDescriptorUpdatedV1", [
      { no: 1, name: "eServiceId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "catalogDescriptor",
        kind: "message",
        T: () => CatalogDescriptorV1,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemDescriptorUpdatedV1>
  ): CatalogItemDescriptorUpdatedV1 {
    const message = { eServiceId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemDescriptorUpdatedV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemDescriptorUpdatedV1
  ): CatalogItemDescriptorUpdatedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string eServiceId */ 1:
          message.eServiceId = reader.string();
          break;
        case /* catalog.CatalogDescriptorV1 catalogDescriptor */ 2:
          message.catalogDescriptor = CatalogDescriptorV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogDescriptor
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemDescriptorUpdatedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string eServiceId = 1; */
    if (message.eServiceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.eServiceId);
    /* catalog.CatalogDescriptorV1 catalogDescriptor = 2; */
    if (message.catalogDescriptor)
      CatalogDescriptorV1.internalBinaryWrite(
        message.catalogDescriptor,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemDescriptorUpdatedV1
 */
export const CatalogItemDescriptorUpdatedV1 =
  new CatalogItemDescriptorUpdatedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovedAttributesFromEserviceToDescriptorsV1$Type extends MessageType<MovedAttributesFromEserviceToDescriptorsV1> {
  constructor() {
    super("catalog.MovedAttributesFromEserviceToDescriptorsV1", [
      { no: 1, name: "catalogItem", kind: "message", T: () => CatalogItemV1 },
    ]);
  }
  create(
    value?: PartialMessage<MovedAttributesFromEserviceToDescriptorsV1>
  ): MovedAttributesFromEserviceToDescriptorsV1 {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<MovedAttributesFromEserviceToDescriptorsV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MovedAttributesFromEserviceToDescriptorsV1
  ): MovedAttributesFromEserviceToDescriptorsV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* catalog.CatalogItemV1 catalogItem */ 1:
          message.catalogItem = CatalogItemV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogItem
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MovedAttributesFromEserviceToDescriptorsV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* catalog.CatalogItemV1 catalogItem = 1; */
    if (message.catalogItem)
      CatalogItemV1.internalBinaryWrite(
        message.catalogItem,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.MovedAttributesFromEserviceToDescriptorsV1
 */
export const MovedAttributesFromEserviceToDescriptorsV1 =
  new MovedAttributesFromEserviceToDescriptorsV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemRiskAnalysisAddedV1$Type extends MessageType<CatalogItemRiskAnalysisAddedV1> {
  constructor() {
    super("catalog.CatalogItemRiskAnalysisAddedV1", [
      { no: 1, name: "catalogItem", kind: "message", T: () => CatalogItemV1 },
      {
        no: 2,
        name: "catalogRiskAnalysisId",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemRiskAnalysisAddedV1>
  ): CatalogItemRiskAnalysisAddedV1 {
    const message = { catalogRiskAnalysisId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemRiskAnalysisAddedV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemRiskAnalysisAddedV1
  ): CatalogItemRiskAnalysisAddedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* catalog.CatalogItemV1 catalogItem */ 1:
          message.catalogItem = CatalogItemV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogItem
          );
          break;
        case /* string catalogRiskAnalysisId */ 2:
          message.catalogRiskAnalysisId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemRiskAnalysisAddedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* catalog.CatalogItemV1 catalogItem = 1; */
    if (message.catalogItem)
      CatalogItemV1.internalBinaryWrite(
        message.catalogItem,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* string catalogRiskAnalysisId = 2; */
    if (message.catalogRiskAnalysisId !== "")
      writer
        .tag(2, WireType.LengthDelimited)
        .string(message.catalogRiskAnalysisId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemRiskAnalysisAddedV1
 */
export const CatalogItemRiskAnalysisAddedV1 =
  new CatalogItemRiskAnalysisAddedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemRiskAnalysisUpdatedV1$Type extends MessageType<CatalogItemRiskAnalysisUpdatedV1> {
  constructor() {
    super("catalog.CatalogItemRiskAnalysisUpdatedV1", [
      { no: 1, name: "catalogItem", kind: "message", T: () => CatalogItemV1 },
      {
        no: 2,
        name: "catalogRiskAnalysisId",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemRiskAnalysisUpdatedV1>
  ): CatalogItemRiskAnalysisUpdatedV1 {
    const message = { catalogRiskAnalysisId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemRiskAnalysisUpdatedV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemRiskAnalysisUpdatedV1
  ): CatalogItemRiskAnalysisUpdatedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* catalog.CatalogItemV1 catalogItem */ 1:
          message.catalogItem = CatalogItemV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogItem
          );
          break;
        case /* string catalogRiskAnalysisId */ 2:
          message.catalogRiskAnalysisId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemRiskAnalysisUpdatedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* catalog.CatalogItemV1 catalogItem = 1; */
    if (message.catalogItem)
      CatalogItemV1.internalBinaryWrite(
        message.catalogItem,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* string catalogRiskAnalysisId = 2; */
    if (message.catalogRiskAnalysisId !== "")
      writer
        .tag(2, WireType.LengthDelimited)
        .string(message.catalogRiskAnalysisId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemRiskAnalysisUpdatedV1
 */
export const CatalogItemRiskAnalysisUpdatedV1 =
  new CatalogItemRiskAnalysisUpdatedV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CatalogItemRiskAnalysisDeletedV1$Type extends MessageType<CatalogItemRiskAnalysisDeletedV1> {
  constructor() {
    super("catalog.CatalogItemRiskAnalysisDeletedV1", [
      { no: 1, name: "catalogItem", kind: "message", T: () => CatalogItemV1 },
      {
        no: 2,
        name: "catalogRiskAnalysisId",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<CatalogItemRiskAnalysisDeletedV1>
  ): CatalogItemRiskAnalysisDeletedV1 {
    const message = { catalogRiskAnalysisId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CatalogItemRiskAnalysisDeletedV1>(
        this,
        message,
        value
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CatalogItemRiskAnalysisDeletedV1
  ): CatalogItemRiskAnalysisDeletedV1 {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* catalog.CatalogItemV1 catalogItem */ 1:
          message.catalogItem = CatalogItemV1.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.catalogItem
          );
          break;
        case /* string catalogRiskAnalysisId */ 2:
          message.catalogRiskAnalysisId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CatalogItemRiskAnalysisDeletedV1,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* catalog.CatalogItemV1 catalogItem = 1; */
    if (message.catalogItem)
      CatalogItemV1.internalBinaryWrite(
        message.catalogItem,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* string catalogRiskAnalysisId = 2; */
    if (message.catalogRiskAnalysisId !== "")
      writer
        .tag(2, WireType.LengthDelimited)
        .string(message.catalogRiskAnalysisId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message catalog.CatalogItemRiskAnalysisDeletedV1
 */
export const CatalogItemRiskAnalysisDeletedV1 =
  new CatalogItemRiskAnalysisDeletedV1$Type();
